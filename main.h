#pragma once

#include <QFile>
#include <QTextStream>
#include <QProcess>
#include <QRegularExpression>
#include <QDebug>
#include <cstdio>

QString executable;
bool literate;

/// Opens a QFile based on a file name. If the file name is a dash (-), an stdio channel will be opened
QFile *fileFor(const QString &file, const QIODevice::OpenMode mode)
{
	QFile *f = new QFile;
	if (file == "-")
	{
		if (mode == QIODevice::ReadOnly)
		{
			f->open(stdin, mode);
		}
		else
		{
			f->open(stdout, mode);
		}
	}
	else
	{
		f->setFileName(file);
		f->open(mode);
	}
	if (f->error() != QFile::NoError)
	{
		qFatal("Unable to open %s: %s", qPrintable(file), qPrintable(f->errorString()));
	}
	return f;
}

/// Runs the CoffeeScript compiler on the given input data and returns the result
QByteArray process(const QByteArray &in, bool bare, const QStringList &extraArgs = QStringList())
{
	// setup
	QProcess proc;
	proc.setProgram(executable);
	proc.setArguments(QStringList(extraArgs + (literate ? QStringList("--literate") : QStringList()) +
								  (bare ? QStringList("--bare") : QStringList()))
					  << "--compile"
					  << "--stdio");
	proc.setProcessChannelMode(QProcess::ForwardedErrorChannel);

	// running
	proc.start(QProcess::ReadWrite);
	if (proc.error() != QProcess::UnknownError)
	{
		qFatal("Error while running CoffeeScript: %s", qPrintable(proc.errorString()));
	}
	proc.waitForStarted();
	proc.write(in);
	proc.closeWriteChannel();
	proc.waitForFinished();

	// finalize
	if (proc.error() != QProcess::UnknownError)
	{
		qFatal("Error while running CoffeeScript: %s", qPrintable(proc.errorString()));
	}
	return proc.readAllStandardOutput()
		// the CoffeeScript compiler prepends the following comment to all output. Remove it.
		.replace("// Generated by CoffeeScript 1.8.0\n", "");
}

/// Takes an input device and transforms all the data that can be read through it, according to QML-specific rules
void processQML(QIODevice *in, QIODevice *out)
{
	QTextStream istr(in);
	QTextStream ostr(out);

	// this code is a statemachine. these are the states.
	QString currentFuncIndentation;
	QString func;

	// loop through all lines in the file
	QString line = istr.readLine();
	while (!line.isNull())
	{
		if (!currentFuncIndentation.isNull())
		{
			// we are currently inside a function, so we need to check if it ended (in that case we need to process it)
			if (!line.startsWith(currentFuncIndentation) || line.size() <= currentFuncIndentation.size() ||
				!line.at(currentFuncIndentation.size()).isSpace())
			{
				/* Processing of functions is a bit special:
				 *
				 * * We replace $ with GLOBAL. before processing, and remove it again afterwards
				 *   This prevents CoffeeScript from declaring the variable.
				 * * We also remove some of the stuff added in front and behind the function, and add the QML
				 *   assignment operator (:)
				 * * Last, we split everything at the newlines and merge it again with the correct identation
				 */
				ostr << currentFuncIndentation
					 << QString::fromUtf8(process(func.replace("$", "GLOBAL.").toUtf8(), true))
							.remove("GLOBAL.")
							.remove(QRegularExpression("\\);$"))
							.replace(QRegularExpression("\\(function\\(.*?\\)"), ":")
							.split('\n', QString::SkipEmptyParts)
							.join('\n' + currentFuncIndentation) << '\n';
				currentFuncIndentation = QString();
			}
			else
			{
				func += '\n' + line;
			}
		}
		if (currentFuncIndentation.isNull())
		{
			// we aren't currently inside a function, so start by checking if this is the start of one
			QRegularExpression functionStartExp("([ \t]*)([a-zA-Z0-9_]*)( \\(.*?\\))? [\\-]\\>$");
			QRegularExpressionMatch funcMatch = functionStartExp.match(line);
			if (funcMatch.hasMatch())
			{
				currentFuncIndentation = funcMatch.captured(1);
				func = line;
			}
			else
			{
				// if it isn't the start of a function, handle property bindings
				QRegularExpression propertyBindingExp("(\\w*[a-zA-Z0-9_\\. ]+:\\w*)([^;]+)(;*)");
				QRegularExpressionMatchIterator it = propertyBindingExp.globalMatch(line);
				// firstIndex and lastIndex are used to later add the stuff that came before or
				// after the matched expressions
				int firstIndex = -1, lastIndex = line.size();
				QString tmp;
				bool didRemoveEnd = false;
				while (it.hasNext())
				{
					QRegularExpressionMatch match = it.next();
					if (firstIndex == -1)
					{
						firstIndex = match.capturedStart() + match.capturedLength(1);
					}
					else
					{
						tmp += match.captured(1);
					}
					lastIndex = match.capturedEnd();
					// we append 'a=' here and remove 'var a;a =' later. this makes CoffeeScript treat
					// the statement as an assignment
					QString statement = "a=" + match.captured(2);
					if (statement.endsWith("}"))
					{
						statement = statement.remove(statement.lastIndexOf('}'), 1);
						didRemoveEnd = true;
					}
					tmp += QString::fromUtf8(process(statement.toUtf8(), true)).remove('\n').remove("var a;a =") +
						   match.captured(3).remove(';');
				}
				ostr << line.left(firstIndex) << tmp << line.mid(lastIndex);
				if (didRemoveEnd)
				{
					ostr << '}';
				}
				ostr << '\n';
			}
		}
		line = istr.readLine();
	}
}
